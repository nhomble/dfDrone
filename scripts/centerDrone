#!/usr/bin/env python2

'''
Subscribe to startDrone for the centroids and then
determine the change in (x, y) to recenter the drone. 
The node is also provides the quickness of each new point
to give moveDrone a sense of how fast it must react

The reason we want this node inbetween startDrone and moveDrone
is the fact that I may get a number of false-negatives inbetween
some number of images. This node will require consecutive detections
to be false until randomWalk is initiated.
'''

# python built-ins
import math
import sys
import time

# ROS
import roslib; roslib.load_manifest('dfDrone')
import rospy
from std_msgs.msg import Float64MultiArray

# my messages/modules
import messageDrone

# globals, need to remember previous 
global_publisher = None
global_last_time = None
global_last_centroid = None
# in case I do not see the drone
# I keep track of how many bad "packets"
global_miss = 0
MISS_MAX = 10

DEBUG_STRING = "\t[CENTER_DRONE] "
def main(argv=None):
	if argv is None:
		argv = sys.argv

	rospy.init_node('centerDrone')
	rospy.loginfo(DEBUG_STRING + "centerDrone has initialized")

	dfd_sub = rospy.Subscriber('startDrone', Float64MultiArray, centroidCallback)
	rospy.spin()

def centroidCallback(message):
	rospy.loginfo(DEBUG_STRING + "centroid callback in centerDrone")
	message = messageDrone.DFDMessage(message.data[0] == 1.0, (message.data[1], message.data[2]), message.data[3], message.data[4], message.data[5])

	global global_last_time
	global global_last_centroid
	global global_miss

	if global_last_time is None or global_last_centroid is None:
		global_last_centroid = message
		global_last_time = time.time()
		pass

	delT = time.time() - global_last_time

	xCenter = message.width/2
	yCenter = message.height/2

	if message.isPresent is True:
		rospy.loginfo(DEBUG_STRING + "positive callback in centerDrone")
		# currently let's just center
		global_miss = 0

		# rotate for delX, move linearly for delY
		sendVelocityMessage(xCenter, yCenter, message, delT)
	else:
		rospy.loginfo(DEBUG_STRING + "negative callback in centerDrone")
		rospy.loginfo(DEBUG_STRING + "misses: " + str(global_miss))
		global_miss += 1	
		if global_miss > MISS_MAX:
			rospy.loginfo(DEBUG_STRING + "requesting random walk")
			sendRandomWalk(xCenter, yCenter, message)

	global_last_time = time.time()

# simply just report the difference of the detected centroid and 
def sendVelocityMessage(xc, yc, DFDMessage, delT):
	vel = messageDrone.DFDVelocity(True, DFDMessage.x - xc, DFDMessage.y - yc, DFDMessage.z, delT)
	global_publisher.publish(vel.ros())

# empty velocity
def sendRandomWalk(xc, yc, DFDMessage):
	vel = messageDrone.DFDVelocity(False, None, None, None, None)
	global_publisher.publish(vel.ros())

if __name__ == "__main__":
	global_publisher = rospy.Publisher("centerDrone", Float64MultiArray)
	sys.exit(main())
