#!/usr/bin/env python2

'''
Subscribe to startDrone for the centroids and then
determine the change in (x, y) to recenter the drone. 
The node is also provides the quickness of each new point
to give moveDrone a sense of how fast it must react

The reason we want this node inbetween startDrone and moveDrone
is the fact that I may get a number of false-negatives inbetween
some number of images. This node will require consecutive detections
to be false until randomWalk is initiated.

UPDATE:
So I should use the turtlebot follower to actually follow the drone. So
this node will publish to
'''

# python built-ins
import math
import random
import sys
import time

# ROS
import roslib; roslib.load_manifest('dfDrone')
import rospy
from std_msgs.msg import Float64MultiArray

# my messages/modules
import messageDrone

# globals, need to remember previous 
g_follower = None
g_move = None
g_last_time = None
g_last_centroid = None
# in case I do not see the drone
# I keep track of how many bad "packets"
g_miss = 0
# keep track of good "packets"
g_found = 0
MISS_MAX = 10
FOUND_MIN = 3

DEBUG_STRING = "\t[CENTER_DRONE] "
def main(argv=None):
	if argv is None:
		argv = sys.argv

	rospy.init_node('centerDrone')
	rospy.loginfo(DEBUG_STRING + "centerDrone has initialized")

	dfd_sub = rospy.Subscriber('startDrone', Float64MultiArray, centroidCallback)

def centroidCallback(message):
	message = messageDrone.DFDMessage(message.data[0] == 1.0, (message.data[1], message.data[2]), message.data[3], message.data[4], message.data[5], message.data[6])

	global g_last_time
	global g_last_centroid
	global g_miss
	global g_found

	if g_last_time is None or g_last_centroid is None:
		g_last_centroid = message
		g_last_time = time.time()
		pass

	delT = time.time() - g_last_time

	if message.isPresent is True:
#		rospy.loginfo(DEBUG_STRING + "positive callback in centerDrone")
		g_miss = 0
		g_found += 1
		rospy.loginfo(DEBUG_STRING + "given x: " + str(message.x))
		newZ = getZPosition(message.area)

		if g_found > FOUND_MIN:
			#rospy.loginfo(DEBUG_STRING + "Z: " + str(newZ) + "X: " + str(message.x))
			sendVelocityMessage(message, delT, newZ)
			g_found = 0
	else:
#		rospy.loginfo(DEBUG_STRING + "negative callback in centerDrone")
#		rospy.loginfo(DEBUG_STRING + "misses: " + str(g_miss))
		g_found = 0
		g_miss += 1	
		if g_miss > MISS_MAX:
			rospy.loginfo(DEBUG_STRING + "requesting random walk")
			sendRandomWalk(message.width, message.height)
			g_miss = 0
	g_last_time = time.time()

# so given the area of the turtlebot_blob
# I am going to guess about how far I am from the 
# ARDrone by the amount of area I see
def getZPosition(area):
	goalArea = 200000.0
	z = (goalArea - area)
#	rospy.loginfo(DEBUG_STRING + " calculated z: " + str(z))
	z /= 10000
	return z

# not using all of the variables right now until I figure out what
# turtlebot follower
def sendVelocityMessage(DFDMessage, delT, newZ):
	xCenter = DFDMessage.width // 2
	yCenter = DFDMessage.height // 2
	vel = messageDrone.DFDVelocity(True, DFDMessage.x - xCenter, DFDMessage.y - yCenter, newZ, delT)
	g_follower.publish(vel.ros())

# random velocity
# just give the turtlebot follower a random (x,y,z)
def sendRandomWalk(width, height):
	vel = messageDrone.DFDVelocity(False, None, None, None, None)

	vel.x = random.uniform(-3, 3) * width
	vel.y = random.uniform(-3, 3) * height
	vel.z = random.randint(-5, 5) * 10.0
#	rospy.loginfo("\t" + DEBUG_STRING + " randomwalk " + str(vel.x) + " " + str(vel.y) + " " + str(vel.z))
	g_follower.publish(vel.ros())

if __name__ == "__main__":
	g_follower = rospy.Publisher("centerDrone", Float64MultiArray)
	sys.exit(main())
