#!/usr/bin/env python2

# python built-ins
import random
import sys

# ROS
import roslib; roslib.load_manifest('dfDrone')
import rospy
import tf.transformations
from geometry_msgs.msg import Twist
from std_msgs.msg import Float64MultiArray

# my modules
import messageDrone

'''
subscribe to centerDrone and given the
velocity messages, I determine the necessary
twist messages
'''

g_cmd_pub = None

DEBUG_STRING = "\t\t[MOVE_DRONE] "

# just define a global delay
DELAY = 1
def main(argv=None):
	if argv is None:
		argv = sys.argv

	rospy.init_node('moveDrone')
	rospy.loginfo(DEBUG_STRING + "moveDrone has initialized")
	sub = rospy.Subscriber('centerDrone', Float64MultiArray, moveCallback)
	rospy.spin()

# check whether or we actually have a velocity or I need to 
# random walk
def moveCallback(velocity):
	vel = messageDrone.DFDVelocity((velocity.data[0] == 1.0), velocity.data[1], velocity.data[2], velocity.data[3], velocity.data[4])
	if vel.isPresent is True:
		move(vel)
	else:
		twoBit = random.randint(0, 3)
		rospy.loginfo(DEBUG_STRING + "random walk " + str(twoBit))
	
		options = {0:r0, 1:r1, 2:r2, 3:r3}
		options[twoBit]()
		
		rospy.sleep(1)
		twist = Twist()
		g_cmd_pub.publish(twist)

# 4 possibilities
#	0: linear movement, no rotational movement
#	1: no linear movement, no rotational movement
#	2: no linear movement, rotational movement
#	3: linear movement, rotational movement
def r0():
	vel = random.uniform(-3, 3)
	twist = Twist()
	twist.linear.x = vel

	g_cmd_pub.publish(twist)

def r1():
	twist = Twist()
	g_cmd_pub.publish(twist)

def r2():
	rot = random.uniform(-3, 3)
	twist = Twist()
	twist.angular.z = rot

	g_cmd_pub.publish(twist)

def r3():
	r0()
	rospy.sleep(DELAY/2)
	r2()

# assume the last centroid was at the center of our view
# must send rotational message first then linear message

# 4 rotations at rot.y = 2.5 equals one full circle
def move(vel):
	twist = Twist()
	twist.linear.x = 2*vel.delY
	g_cmd_pub.publish(twist)
	rospy.loginfo(DEBUG_STRING + "linear movement")
	rospy.sleep(DELAY)

	twist = Twist()
	yDist = vel.delY * vel.delay
	theta = Math.atab(yDist)
	twist.angular.z = theta * 2 / vel.delay
	rospy.loginfo(DEBUG_STRING + "angular movement")
	rospy.sleep(DELAY)

if __name__ == "__main__":
	g_cmd_pub = rospy.Publisher('/cmd_vel_mux/input/teleop', Twist)
	sys.exit(main())
