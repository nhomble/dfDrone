#!/usr/bin/env python2

# python built-ins
import random
import sys

# ROS
import roslib; roslib.load_manifest('dfDrone')
import rospy
import tf.transformations
from geometry_msgs.msg import Twist
from std_msgs.msg import Float64MultiArray

# my modules
import messageDrone

'''
subscribe to centerDrone and given the
velocity messages, I determine the necessary
twist messages
'''

g_cmd_pub = None
g_tFollower = None

ZGOAL = 10.0
ZSCALE = 2.0
XSCALE = 2.0

DEBUG_STRING = "\t\t[MOVE_DRONE] "

# just define a global delay
DELAY = 1
def main(argv=None):
	if argv is None:
		argv = sys.argv

	rospy.init_node('moveDrone')
	rospy.loginfo(DEBUG_STRING + "moveDrone has initialized")
	sub = rospy.Subscriber('centerDrone', Float64MultiArray, moveCallback)
	rospy.spin()

# check whether or we actually have a velocity or I need to 
# random walk
def moveCallback(velocity):
	flag = velocity.data[0]
	x = velocity.data[1]
	y = velocity.data[2]
	z = velocity.data[3]
	
	twist = Twist()

	twist.linear.x = (z - ZGOAL) * ZSCALE
	twist.angular.z = -x * XSCALE

	# less drastic movement?
	if flag == 1.0:
		twist.linear.x /= 2
		twist.angular.z /= 2
	
	g_cmd_pub.publish(twist)

def move(vel):
	twist = Twist()
	twist.linear.x = 2*vel.delY
	g_cmd_pub.publish(twist)
	rospy.loginfo(DEBUG_STRING + "linear movement")
	rospy.sleep(DELAY)

	twist = Twist()
	yDist = vel.delY * vel.delay
	theta = Math.atab(yDist)
	twist.angular.z = theta * 2 / vel.delay
	rospy.loginfo(DEBUG_STRING + "angular movement")
	rospy.sleep(DELAY)

if __name__ == "__main__":
	g_cmd_pub = rospy.Publisher('/cmd_vel_mux/input/teleop', Twist)
	sys.exit(main())
