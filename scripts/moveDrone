#!/usr/bin/env python2

# python built-ins
import random
import subprocess
import sys

# ROS
import roslib; roslib.load_manifest('dfDrone')
import rospy
import tf.transformations
from create_node.msg import TurtlebotSensorState
from geometry_msgs.msg import Twist
from std_msgs.msg import Float64MultiArray

# my modules
import messageDrone

'''
subscribe to centerDrone and given the
velocity messages, I determine the necessary
twist messages

also subscribe to turtlebot node to detect collisions
'''

g_cmd_pub = None
g_tFollower = None

# collision is the signal
# count is just me hacking
g_collision = 0
g_count = 0
COUNT_MAX = 3

DEBUG_STRING = "\t\t[MOVE_DRONE] "

def main(argv=None):
	if argv is None:
		argv = sys.argv

	rospy.init_node('moveDrone')
	rospy.loginfo(DEBUG_STRING + "moveDrone has initialized")
	subprocess.Popen(["espeak", "move drone has initialized"])
	sub = rospy.Subscriber('centerDrone', Float64MultiArray, moveCallback)
	sub2 = rospy.Subscriber('/mobile_base/sensors/core', TurtlebotSensorState, collisionCallback)
	rospy.spin()

# TODO thread safe?
def collisionCallback(TurtlebotSensorState):
	global g_collision
	if g_collision == 0:
		g_collision = TurtlebotSensorState.bumps_wheeldrops
		

# check whether or we actually have a velocity or I need to 
# random walk
def moveCallback(velocity):
	global g_collision
	global g_count
	flag = velocity.data[0]
	x = velocity.data[1]
	y = velocity.data[2]
	z = velocity.data[3]

	twist = Twist()
	# right bumper
	if g_collision != 0:
		subprocess.Popen(["espeak", "we have collided with something"])
	if g_collision == 1:
		twist.linear.x = -2
		twist.angular.z = -3
		g_cmd_pub.publish(twist)
		g_count += 1
		if g_count > COUNT_MAX:	
			g_collision = 0
			g_count = 0
		return
	# left bumper
	elif g_collision == 2:
		twist.linear.x = -2
		twist.angular.z = 3
		g_cmd_pub.publish(twist)
		g_count += 1
		if g_count > COUNT_MAX:
			g_collision = 0
			g_count = 0
		return
	# both
	elif g_collision == 3:
		twist.linear.x = -3
		twist.angular.z = 3
		g_cmd_pub.publish(twist)
		g_count += 1
		if g_count > COUNT_MAX:
			g_collision = 0
			g_count = 0
		return

#		simpler
#			if I see it just move forward
#			if I don't see it just move backward
#	
#			try to zig zag my way to centering the drone
	if flag == 1.0:
		subprocess.Popen(["espeak", "moving towards the drone"])
		twist.linear.x = z
		if x < 0:
			twist.angular.z = .5
		elif x == 0:
			twist.angular.z = 0
		else:
			twist.angular.z = -.5
	else:
		subprocess.Popen(["espeak", "where is it"])
		twist.linear.x = z/2
		twist.angular.z = x
	
	rospy.loginfo(DEBUG_STRING + " Twist: linear: " + str(twist.linear.x) + " angular: " + str(twist.angular.z))

	g_cmd_pub.publish(twist)

if __name__ == "__main__":
	g_cmd_pub = rospy.Publisher('/cmd_vel_mux/input/teleop', Twist)
	sys.exit(main())
